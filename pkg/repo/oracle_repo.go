package repo

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	_ "github.com/sijms/go-ora/v2"
)

type OracleRepo struct {
	db *sql.DB
}

func NewOracleRepo(url string) (*OracleRepo, error) {
	db, err := sql.Open("oracle", url)
	if err != nil {
		return nil, fmt.Errorf("opening databse connection: %w", err)
	}
	db.SetMaxOpenConns(3)
	db.SetConnMaxLifetime(time.Second * 20)

	if err = db.PingContext(context.Background()); err != nil {
		return nil, fmt.Errorf("error testing database connection: %w", err)
	}

	return &OracleRepo{
		db: db,
	}, nil
}

func (o *OracleRepo) Init(rowCount int, balance float64) error {
	const tableStmt = `CREATE TABLE account (
						  				 id NUMBER GENERATED BY DEFAULT AS IDENTITY,
						  				 balance NUMBER NOT NULL,
						  				 PRIMARY KEY (id)
						  			 )`

	if _, err := o.db.ExecContext(context.Background(), tableStmt); err != nil {
		return fmt.Errorf("creating table: %w", err)
	}

	const insertStmt = `INSERT INTO account (balance)
											SELECT :balance
											FROM dual
											CONNECT BY level <= :count`

	rowCountArg := sql.Named("count", rowCount)
	balanceArg := sql.Named("balance", balance)
	if _, err := o.db.ExecContext(context.Background(), insertStmt, rowCountArg, balanceArg); err != nil {
		return fmt.Errorf("seeding table: %w", err)
	}

	return nil
}

func (o *OracleRepo) Deinit() error {
	const stmt = `DROP TABLE account`

	_, err := o.db.ExecContext(context.Background(), stmt)
	if err != nil {
		return fmt.Errorf("dropping table: %w", err)
	}

	return nil
}

func (o *OracleRepo) FetchIDs(count int) ([]any, error) {
	const stmt = `SELECT id 
								FROM (
									SELECT id 
									FROM account 
									ORDER BY DBMS_RANDOM.VALUE
								)
								WHERE ROWNUM <= :count`

	countArg := sql.Named("count", count)
	rows, err := o.db.QueryContext(context.Background(), stmt, countArg)
	if err != nil {
		return nil, fmt.Errorf("querying for rows: %w", err)
	}

	var accountIDs []any
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("scanning id: %w", err)
		}
		accountIDs = append(accountIDs, id)
	}

	return accountIDs, nil
}

func (o *OracleRepo) PerformTransfer(from, to any, amount float64) (elapsed time.Duration, err error) {
	// Timeout queries after 5s (configure to your requirements).
	timeout, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	start := time.Now()
	defer func() {
		elapsed = time.Since(start)
	}()

	const stmt = `UPDATE account
								SET balance = CASE 
									WHEN id = :from_account THEN balance - :amount
									WHEN id = :to_account THEN balance + :amount
									ELSE balance
								END
								WHERE id = :from_account OR id = :to_account`

	fromIDArg := sql.Named("from_account", from)
	toIDArg := sql.Named("to_account", to)
	amountArg := sql.Named("amount", amount)
	_, err = o.db.ExecContext(timeout, stmt, fromIDArg, toIDArg, amountArg)
	return
}

func (o *OracleRepo) IsReady() (bool, error) {
	return true, nil
}
